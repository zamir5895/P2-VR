/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * Licensed under the Oculus SDK License Agreement (the "License");
 * you may not use the Oculus SDK except in compliance with the License,
 * which is provided at the time of installation or download, or which
 * otherwise accompanies this software in either electronic or hard copy form.
 *
 * You may obtain a copy of the License at
 *
 * https://developer.oculus.com/licenses/oculussdk/
 *
 * Unless required by applicable law or agreed to in writing, the Oculus SDK
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System.Buffers;
using UnityEngine;
using UnityEngine.Assertions;
using static Oculus.Interaction.GrabFreeTransformer;

namespace Oculus.Interaction
{
    /// <summary>
    /// An <see cref="ITransformer"/> that can translate and rotate a rigidbody using any number of grab points
    /// applying velocities directly so it can still interact with other colliders.
    /// See <see cref="GrabFreeTransformer"/> for a version that applies movement to the transform directly.
    /// </summary>
    public class GrabFreePhysicsTransformer : MonoBehaviour, ITransformer
    {
        [Tooltip("Strength of the velocity applied during fixed update")]
        [SerializeField]
        private float _velocityFactor = 60f;
        /// <summary>
        /// Strength of the velocity applied during fixed update
        /// </summary>
        public float VelocityFactor
        {
            get => _velocityFactor;
            set => _velocityFactor = value;
        }

        [Tooltip("Strength of the angular velocity applied during fixed update")]
        [SerializeField]
        private float _angularVelocityFactor = 0.6f;
        /// <summary>
        /// Strength of the angular velocity applied during fixed update
        /// </summary>
        public float AngularVelocityFactor
        {
            get => _angularVelocityFactor;
            set => _angularVelocityFactor = value;
        }

        [Tooltip("Maximum delta for the linear velocity applied during fixed update")]
        [SerializeField]
        private float _maxLinearDelta = 100f;
        /// <summary>
        /// Maximum delta for the linear velocity applied during fixed update
        /// </summary>
        public float MaxLinearDelta
        {
            get => _maxLinearDelta;
            set => _maxLinearDelta = value;
        }

        [Tooltip("Maximum delta for the angular velocity applied during fixed update")]
        [SerializeField]
        private float _maxAngularDelta = 200f;
        /// <summary>
        /// Maximum delta for the angular velocity applied during fixed update
        /// </summary>
        public float MaxAngularDelta
        {
            get => _maxAngularDelta;
            set => _maxAngularDelta = value;
        }

        [SerializeField, Optional(OptionalAttribute.Flag.AutoGenerated)]
        [Tooltip("Rigidbody to which the velocity will be applied.")]
        private Rigidbody _rigidbody;

        private IGrabbable _grabbable;
        private Pose _grabDeltaInLocalSpace;
        private Quaternion _lastRotation = Quaternion.identity;

        private GrabPointDelta[] _deltas;

        private bool _isTransforming = false;
        private Vector3 _targetPosition;
        private Quaternion _targetRotation;

        protected virtual void Reset()
        {
            _rigidbody = this.GetComponent<Rigidbody>();
        }

        public void Initialize(IGrabbable grabbable)
        {
            _grabbable = grabbable;
            if (_rigidbody == null)
            {
                _rigidbody = _grabbable.Transform.GetComponent<Rigidbody>();
            }

            this.AssertField(_rigidbody, nameof(_rigidbody),
                howToFix: $"Ensure that the {nameof(IGrabbable)} initializing this transformer has a {nameof(Rigidbody)} " +
                $"in its target, or reference it directly in the component.");
        }

        public void BeginTransform()
        {
            int count = _grabbable.GrabPoints.Count;

            //rent space only while using
            _deltas = ArrayPool<GrabPointDelta>.Shared.Rent(count);

            InitializeDeltas(count, _grabbable.GrabPoints, ref _deltas);
            Vector3 centroid = GetCentroid(_grabbable.GrabPoints);

            Transform targetTransform = _grabbable.Transform;
            _grabDeltaInLocalSpace = new Pose(
                targetTransform.InverseTransformVector(centroid - targetTransform.position),
                targetTransform.rotation);
            _lastRotation = Quaternion.identity;

            _targetRotation = _rigidbody.rotation;
            _targetPosition = _rigidbody.position;

            Assert.IsFalse(_isTransforming, $"Unbalanced calls to {nameof(GrabFreePhysicsTransformer)}.{nameof(BeginTransform)}");
            _isTransforming = true;
        }

        public void UpdateTransform()
        {
            if (!_isTransforming)
            {
                return;
            }

            int count = _grabbable.GrabPoints.Count;
            Transform targetTransform = _grabbable.Transform;

            Vector3 localPosition = UpdateTransformerPointData(_grabbable.GrabPoints, ref _deltas);

            _lastRotation = UpdateRotation(count, _deltas) * _lastRotation;
            _targetRotation = _lastRotation * _grabDeltaInLocalSpace.rotation;
            _targetPosition = localPosition - targetTransform.TransformVector(_grabDeltaInLocalSpace.position);
        }

        public void EndTransform()
        {
            Assert.IsTrue(_isTransforming, $"Unbalanced calls to {nameof(GrabFreePhysicsTransformer)}.{nameof(EndTransform)}");
            _isTransforming = false;

            //return the uneeded space
            ArrayPool<GrabPointDelta>.Shared.Return(_deltas);
            _deltas = null;
        }

        private void FixedUpdate()
        {
            if (_isTransforming)
            {
                ApplyVelocity(_targetPosition, _targetRotation);
            }
        }

        private void ApplyVelocity(Vector3 targetPosition, Quaternion targetRotation)
        {
            Vector3 positionDelta = targetPosition - _rigidbody.transform.position;
            Vector3 velocityTarget = positionDelta * _velocityFactor;
            if (!float.IsNaN(velocityTarget.x))
            {
#pragma warning disable CS0618 // Type or member is obsolete
                _rigidbody.velocity = Vector3.MoveTowards(_rigidbody.velocity, velocityTarget, _maxLinearDelta);
#pragma warning restore CS0618 // Type or member is obsolete
            }

            Quaternion rotationDelta = targetRotation * Quaternion.Inverse(_rigidbody.transform.rotation);
            rotationDelta.ToAngleAxis(out float angle, out Vector3 axis);
            if (angle > 180f)
            {
                angle -= 360f;
            }
            Vector3 angularTarget = angle * axis * _angularVelocityFactor;
            if (!Mathf.Approximately(angle, 0f)
                && !float.IsNaN(angularTarget.x))
            {
                _rigidbody.angularVelocity = Vector3.MoveTowards(_rigidbody.angularVelocity,
                        angularTarget, _maxAngularDelta);
            }
        }

        #region Injects

        public void InjectOptionalRigidbody(Rigidbody rigidbody)
        {
            _rigidbody = rigidbody;
        }

        #endregion
    }
}
