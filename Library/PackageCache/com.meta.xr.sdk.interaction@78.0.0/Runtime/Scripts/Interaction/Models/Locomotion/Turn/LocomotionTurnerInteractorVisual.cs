/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * Licensed under the Oculus SDK License Agreement (the "License");
 * you may not use the Oculus SDK except in compliance with the License,
 * which is provided at the time of installation or download, or which
 * otherwise accompanies this software in either electronic or hard copy form.
 *
 * You may obtain a copy of the License at
 *
 * https://developer.oculus.com/licenses/oculussdk/
 *
 * Unless required by applicable law or agreed to in writing, the Oculus SDK
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using Oculus.Interaction.Input;
using UnityEngine;

namespace Oculus.Interaction.Locomotion
{
    /// <summary>
    /// Drives the visual affordances of a <see cref="LocomotionTurnerInteractor"/>,
    /// such as the activation, positioning and highlighting of turner arrows.
    /// </summary>
    public class LocomotionTurnerInteractorVisual : MonoBehaviour
    {
        [SerializeField]
        private LocomotionTurnerInteractor _turner;

        [SerializeField, Optional]
        private TurnerEventBroadcaster _broadcaster;

        [SerializeField, Optional]
        private Transform _lookAt;

        [SerializeField, Optional(OptionalAttribute.Flag.AutoGenerated)]
        private Transform _root;

        [SerializeField]
        private TurnArrowVisuals _visuals;

        [SerializeField, Interface(typeof(IAxis1D)), Optional]
        private UnityEngine.Object _progress;
        private IAxis1D Progress { get; set; }

        [SerializeField]
        private float _verticalOffset = 0.02f;

        /// <summary>
        /// The vertical offset above the <see cref="LocomotionTurnerInteractor.MidPoint"/>
        /// where the arrow visuals will be positioned.
        /// </summary>
        public float VerticalOffset
        {
            get => _verticalOffset;
            set => _verticalOffset = value;
        }

        protected bool _started;

        protected virtual void Awake()
        {
            Progress = _progress as IAxis1D;
        }

        protected virtual void Start()
        {
            this.BeginStart(ref _started);

            this.AssertField(_turner, nameof(_turner));

            if (_root == null)
            {
                _root = this.transform;
            }
            this.AssertField(_root, nameof(_root));
            this.AssertField(_visuals, nameof(_visuals));

            this.EndStart(ref _started);
        }

        protected virtual void OnEnable()
        {
            if (_started)
            {
                if (_turner != null)
                {
                    _turner.WhenStateChanged += HandleTurnerStateChanged;
                    _turner.WhenPreprocessed += HandleTurnerPostprocessed;
                }
            }
        }

        protected virtual void OnDisable()
        {
            if (_started)
            {
                if (_turner != null)
                {
                    _turner.WhenStateChanged -= HandleTurnerStateChanged;
                    _turner.WhenPreprocessed -= HandleTurnerPostprocessed;
                }
            }
        }

        private void HandleTurnerStateChanged(InteractorStateChangeArgs stateArgs)
        {
            if (stateArgs.NewState == InteractorState.Disabled)
            {
                _visuals.DisableVisuals();
            }
        }

        private void HandleTurnerPostprocessed()
        {
            if (_turner != null && _turner.State == InteractorState.Disabled)
            {
                return;
            }

            UpdatePose(_turner.MidPoint);

            _visuals.Progress = Progress.Value();
            _visuals.Value = _turner.Value();
            _visuals.FollowArrow = _broadcaster == null || _broadcaster.TurnMethod == TurnerEventBroadcaster.TurnMode.Snap;
            _visuals.HighLight = _turner.State == InteractorState.Select;

            _visuals.UpdateVisual();
        }

        private void UpdatePose(Pose origin)
        {
            Vector3 forward = origin.forward;
            if (_lookAt != null)
            {
                forward = Vector3.ProjectOnPlane(origin.position - _lookAt.position, origin.up).normalized;
            }
            Vector3 position = origin.position - forward * _visuals.Radius + origin.up * _verticalOffset;
            Quaternion rotation = Quaternion.LookRotation(forward, origin.up);

            _root.SetPositionAndRotation(position, rotation);
        }

        #region Inject

        /// <summary>
        /// Injects all required dependencies for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectAllLocomotionTurnerInteractorArrowsVisual(
            LocomotionTurnerInteractor turner, TurnArrowVisuals visuals)
        {
            InjectTurner(turner);
            InjectVisuals(visuals);
        }

        /// <summary>
        /// Sets the underlying <see cref="LocomotionTurnerInteractor"/> for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectTurner(LocomotionTurnerInteractor turner)
        {
            _turner = turner;
        }

        /// <summary>
        /// Sets the underlying root <see cref="Transform"/> for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectOptionalRoot(Transform root)
        {
            _root = root;
        }

        /// <summary>
        /// Sets the underlying <see cref="TurnArrowVisuals"/> for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectVisuals(TurnArrowVisuals visuals)
        {
            _visuals = visuals;
        }

        /// <summary>
        /// Sets the underlying optional LookAt <see cref="Transform"/> for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectOptionalLookAt(Transform lookAt)
        {
            _lookAt = lookAt;
        }

        /// <summary>
        /// Sets the underlying optional <see cref="IAxis1D"/> for a dynamically instantiated
        /// <see cref="LocomotionTurnerInteractorVisual"/>.
        /// This method exists to support Interaction SDK's dependency injection pattern and is not
        /// needed for typical Unity Editor-based usage.
        /// </summary>
        public void InjectOptionalProgress(IAxis1D progress)
        {
            _progress = progress as UnityEngine.Object;
            Progress = progress;
        }

        #endregion
    }
}
